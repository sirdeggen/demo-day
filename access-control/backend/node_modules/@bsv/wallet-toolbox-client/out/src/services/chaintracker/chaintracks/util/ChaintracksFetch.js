"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChaintracksFetch = void 0;
const sdk_1 = require("@bsv/sdk");
const utilityHelpers_1 = require("../../../../utility/utilityHelpers");
/**
 * This class implements the ChaintracksFetchApi
 * using the @bsv/sdk `defaultHttpClient`.
 */
class ChaintracksFetch {
    constructor() {
        this.httpClient = (0, sdk_1.defaultHttpClient)();
    }
    async download(url) {
        for (let retry = 0;; retry++) {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/octet-stream'
                }
            });
            if (!response.ok) {
                if (response.statusText === 'Too Many Requests' && retry < 3) {
                    // WhatsOnChain rate limits requests, so backoff and retry
                    await (0, utilityHelpers_1.wait)(1000 * (retry + 1));
                    continue;
                }
                throw new Error(`Failed to download from ${url}: ${response.statusText}`);
            }
            const data = await response.arrayBuffer();
            return new Uint8Array(data);
        }
    }
    async fetchJson(url) {
        const requestJsonOptions = {
            method: 'GET',
            headers: {
                Accept: 'application/json'
            }
        };
        let json;
        for (let retry = 0;; retry++) {
            const response = await fetch(url, requestJsonOptions);
            if (!response.ok) {
                if (response.statusText === 'Too Many Requests' && retry < 3) {
                    await (0, utilityHelpers_1.wait)(1000 * (retry + 1));
                    continue;
                }
                throw new Error(`Failed to fetch JSON from ${url}: ${response.statusText}`);
            }
            json = (await response.json());
            break;
        }
        return json;
    }
    pathJoin(baseUrl, subpath) {
        // Ensure the subpath doesn't start with a slash to avoid issues
        const cleanSubpath = subpath.replace(/^\/+/, '');
        if (!baseUrl.endsWith('/'))
            baseUrl += '/';
        // Create a new URL object and append the subpath
        const url = new URL(cleanSubpath, baseUrl);
        return url.toString();
    }
}
exports.ChaintracksFetch = ChaintracksFetch;
//# sourceMappingURL=ChaintracksFetch.js.map