"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletLogger = void 0;
exports.logWalletError = logWalletError;
exports.logCreateActionArgs = logCreateActionArgs;
const sdk_1 = require("@bsv/sdk");
const WalletError_1 = require("./sdk/WalletError");
class WalletLogger {
    constructor(log) {
        this.indent = 0;
        this.logs = [];
        this.isOrigin = true;
        this.isError = false;
        if (log) {
            const lo = typeof log === 'string' ? JSON.parse(log) : log;
            this.indent = lo.indent || 0;
            this.logs = lo.logs || [];
            this.isOrigin = this.indent === 0;
            this.level = lo.level;
        }
    }
    logAny(message) {
        if (!message)
            return '';
        if (typeof message === 'string')
            return message;
        if (typeof message === 'object')
            return JSON.stringify(message);
        return '';
    }
    toAdd(isBegin, isEnd, isError, message, optionalParams) {
        let add = '';
        if (message)
            add += this.logAny(message);
        if (optionalParams)
            for (const p of optionalParams)
                add += this.logAny(p);
        let log = {
            when: Date.now(),
            indent: this.indent,
            isBegin,
            isEnd,
            isError,
            log: add
        };
        return log;
    }
    stampLog(isBegin, isEnd, isError, message, optionalParams) {
        const add = this.toAdd(isBegin, isEnd, isError, message, optionalParams);
        this.logs.push(add);
    }
    group(...label) {
        this.stampLog(true, false, false, undefined, label);
        this.indent++;
    }
    groupEnd() {
        this.indent--;
        if (this.indent < 0)
            this.indent = 0;
        this.stampLog(false, true, false);
    }
    log(message, ...optionalParams) {
        this.stampLog(false, false, false, message, optionalParams);
    }
    error(message, ...optionalParams) {
        this.stampLog(false, false, true, message, optionalParams);
        this.isError = true;
    }
    toWalletLoggerJson() {
        const json = {
            isWalletLoggerJson: true,
            indent: this.indent,
            logs: this.logs,
            isError: this.isError
        };
        return json;
    }
    toLogString() {
        let log = '';
        if (this.logs.length > 0) {
            const first = this.logs[0];
            const last = this.logs.slice(-1)[0];
            const msecs = last.when - first.when;
            log += `   msecs WalletLogger ${new Date(first.when).toISOString()} logged ${msecs / 1000} seconds\n`;
            let prev = first;
            const begins = [];
            for (const d of this.logs) {
                let df = (d.when - prev.when).toString();
                df = `${' '.repeat(8 - df.length)}${df}`;
                const what = d.isBegin ? ' begin' : d.isEnd ? ' end' : d.isError ? ' ERROR' : '';
                if (d.isBegin)
                    begins.push(d);
                let m = d.log;
                if (!m && d.isEnd && begins.length > 0) {
                    const begin = begins.pop();
                    m = begin.log;
                }
                log += `${df}${'  '.repeat(d.indent)}${what} ${m}\n`;
                prev = d;
            }
        }
        return log;
    }
    flush() {
        if (this.logs.length > 0) {
            const trace = this.toLogString();
            const output = this.isError ? console.error : console.log;
            if (this.flushFormat === 'json') {
                const name = this.logs[0].log;
                const log = {
                    name,
                    trace
                };
                output(JSON.stringify(log));
            }
            else {
                output(trace);
            }
        }
        const r = this.isOrigin ? undefined : this.toWalletLoggerJson();
        return r;
    }
    merge(log) {
        if (log.logs) {
            this.logs.push(...log.logs);
        }
    }
}
exports.WalletLogger = WalletLogger;
function logWalletError(eu, logger, label) {
    if (!logger)
        return;
    logger.error(label || 'WalletError', WalletError_1.WalletError.unknownToJson(eu));
}
function logCreateActionArgs(args) {
    const o = {
        description: args.description
    };
    if (args.labels)
        o.labels = args.labels;
    if (args.inputBEEF)
        o.inputBEEF = sdk_1.Beef.fromBinary(args.inputBEEF).toLogString();
    if (args.lockTime !== undefined)
        o.lockTime = args.lockTime;
    if (args.version !== undefined)
        o.version = args.version;
    /*
      if (args.inputs) {
  
      }
      if (args.outputs) {
  
      }
      options: validateCreateActionOptions(args.options),
      isSendWith: false,
      isDelayed: false,
      isNoSend: false,
      isNewTx: false,
      isRemixChange: false,
      isSignAction: false,
      randomVals: undefined,
      includeAllSourceTransactions: false,
      isTestWerrReviewActions: false
    */
    return o;
}
//# sourceMappingURL=WalletLogger.js.map