"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAction = createAction;
exports.processAction = processAction;
const sdk_1 = require("@bsv/sdk");
const buildSignableTransaction_1 = require("./buildSignableTransaction");
const completeSignedTransaction_1 = require("./completeSignedTransaction");
const WERR_errors_1 = require("../../sdk/WERR_errors");
async function createAction(wallet, auth, vargs) {
    var _a;
    const r = {};
    const logger = vargs.logger;
    let prior = undefined;
    if (vargs.isNewTx || vargs.isTestWerrReviewActions) {
        prior = await createNewTx(wallet, vargs);
        logger === null || logger === void 0 ? void 0 : logger.log('created new transaction');
        if (vargs.isSignAction) {
            const r = makeSignableTransactionResult(prior, wallet, vargs);
            logger === null || logger === void 0 ? void 0 : logger.log('created signable transaction result');
            return r;
        }
        prior.tx = await (0, completeSignedTransaction_1.completeSignedTransaction)(prior, {}, wallet);
        logger === null || logger === void 0 ? void 0 : logger.log('completed signed transaction');
        r.txid = prior.tx.id('hex');
        const beef = new sdk_1.Beef();
        if (prior.dcr.inputBeef)
            beef.mergeBeef(prior.dcr.inputBeef);
        beef.mergeTransaction(prior.tx);
        logger === null || logger === void 0 ? void 0 : logger.log('merged beef');
        (0, completeSignedTransaction_1.verifyUnlockScripts)(r.txid, beef);
        logger === null || logger === void 0 ? void 0 : logger.log('verified unlock scripts');
        r.noSendChange = (_a = prior.dcr.noSendChangeOutputVouts) === null || _a === void 0 ? void 0 : _a.map(vout => `${r.txid}.${vout}`);
        if (!vargs.options.returnTXIDOnly)
            r.tx = beef.toBinaryAtomic(r.txid);
    }
    const { sendWithResults, notDelayedResults } = await processAction(prior, wallet, auth, vargs);
    logger === null || logger === void 0 ? void 0 : logger.log('processed transaction');
    r.sendWithResults = sendWithResults;
    r.notDelayedResults = notDelayedResults;
    return r;
}
async function createNewTx(wallet, vargs) {
    const logger = vargs.logger;
    const storageArgs = removeUnlockScripts(vargs);
    const dcr = await wallet.storage.createAction(storageArgs);
    const reference = dcr.reference;
    const { tx, amount, pdi } = (0, buildSignableTransaction_1.buildSignableTransaction)(dcr, vargs, wallet);
    logger === null || logger === void 0 ? void 0 : logger.log('built signable transaction');
    const prior = { reference, dcr, args: vargs, amount, tx, pdi };
    return prior;
}
function makeSignableTransactionResult(prior, wallet, args) {
    var _a;
    if (!prior.dcr.inputBeef)
        throw new WERR_errors_1.WERR_INTERNAL('prior.dcr.inputBeef must be valid');
    const txid = prior.tx.id('hex');
    const r = {
        noSendChange: args.isNoSend ? (_a = prior.dcr.noSendChangeOutputVouts) === null || _a === void 0 ? void 0 : _a.map(vout => `${txid}.${vout}`) : undefined,
        signableTransaction: {
            reference: prior.dcr.reference,
            tx: makeSignableTransactionBeef(prior.tx, prior.dcr.inputBeef)
        }
    };
    wallet.pendingSignActions[r.signableTransaction.reference] = prior;
    return r;
}
function makeSignableTransactionBeef(tx, inputBEEF) {
    // This is a special case beef for transaction signing.
    // We only need the transaction being signed, and for each input, the raw source transaction.
    const beef = new sdk_1.Beef();
    for (const input of tx.inputs) {
        if (!input.sourceTransaction)
            throw new WERR_errors_1.WERR_INTERNAL('Every signableTransaction input must have a sourceTransaction');
        beef.mergeRawTx(input.sourceTransaction.toBinary());
    }
    beef.mergeRawTx(tx.toBinary());
    return beef.toBinaryAtomic(tx.id('hex'));
}
function removeUnlockScripts(args) {
    let storageArgs = args;
    if (!storageArgs.inputs.every(i => i.unlockingScript === undefined)) {
        // Never send unlocking scripts to storage, all it needs is the script length.
        storageArgs = { ...args, inputs: [] };
        for (const i of args.inputs) {
            const di = {
                ...i,
                unlockingScriptLength: i.unlockingScript !== undefined ? i.unlockingScript.length : i.unlockingScriptLength
            };
            delete di.unlockingScript;
            storageArgs.inputs.push(di);
        }
    }
    return storageArgs;
}
async function processAction(prior, wallet, auth, vargs) {
    const args = {
        isNewTx: vargs.isNewTx,
        isSendWith: vargs.isSendWith,
        isNoSend: vargs.isNoSend,
        isDelayed: vargs.isDelayed,
        reference: prior ? prior.reference : undefined,
        txid: prior ? prior.tx.id('hex') : undefined,
        rawTx: prior ? prior.tx.toBinary() : undefined,
        sendWith: vargs.isSendWith ? vargs.options.sendWith : [],
        logger: vargs.logger
    };
    const r = await wallet.storage.processAction(args);
    return r;
}
function makeDummyTransactionForOutputSatoshis(vout, satoshis) {
    const tx = new sdk_1.Transaction();
    for (let i = 0; i < vout; i++)
        tx.addOutput({ lockingScript: new sdk_1.Script(), satoshis: 0 });
    tx.addOutput({ lockingScript: new sdk_1.Script(), satoshis });
    return tx;
}
//# sourceMappingURL=createAction.js.map