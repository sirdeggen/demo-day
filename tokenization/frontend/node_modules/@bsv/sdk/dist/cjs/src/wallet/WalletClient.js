"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const window_CWI_js_1 = __importDefault(require("./substrates/window.CWI.js"));
const XDM_js_1 = __importDefault(require("./substrates/XDM.js"));
const WalletWireTransceiver_js_1 = __importDefault(require("./substrates/WalletWireTransceiver.js"));
const HTTPWalletWire_js_1 = __importDefault(require("./substrates/HTTPWalletWire.js"));
const HTTPWalletJSON_js_1 = __importDefault(require("./substrates/HTTPWalletJSON.js"));
const ReactNativeWebView_js_1 = __importDefault(require("./substrates/ReactNativeWebView.js"));
const validationHelpers_js_1 = require("./validationHelpers.js");
const WERR_INVALID_PARAMETER_js_1 = require("./WERR_INVALID_PARAMETER.js");
const MAX_XDM_RESPONSE_WAIT = 200;
/**
 * The SDK is how applications communicate with wallets over a communications substrate.
 */
class WalletClient {
    constructor(substrate = 'auto', originator) {
        if (substrate === 'Cicada') {
            substrate = new WalletWireTransceiver_js_1.default(new HTTPWalletWire_js_1.default(originator));
        }
        if (substrate === 'window.CWI')
            substrate = new window_CWI_js_1.default();
        if (substrate === 'XDM')
            substrate = new XDM_js_1.default();
        if (substrate === 'json-api')
            substrate = new HTTPWalletJSON_js_1.default(originator);
        if (substrate === 'react-native')
            substrate = new ReactNativeWebView_js_1.default(originator);
        if (substrate === 'secure-json-api')
            substrate = new HTTPWalletJSON_js_1.default(originator, 'https://localhost:2121');
        this.substrate = substrate;
        this.originator = originator;
    }
    async connectToSubstrate() {
        if (typeof this.substrate === 'object') {
            return; // substrate is already connected
        }
        const attemptSubstrate = async (factory, timeout) => {
            try {
                const sub = factory();
                let result;
                if (typeof timeout === 'number') {
                    result = await Promise.race([
                        sub.getVersion({}),
                        new Promise((_resolve, reject) => setTimeout(() => reject(new Error('Timed out.')), timeout))
                    ]);
                }
                else {
                    result = await sub.getVersion({});
                }
                if (typeof result !== 'object' || typeof result.version !== 'string') {
                    return { success: false };
                }
                return { success: true, sub };
            }
            catch {
                return { success: false };
            }
        };
        // Try fast substrates first
        const fastAttempts = [
            attemptSubstrate(() => new window_CWI_js_1.default()),
            attemptSubstrate(() => new HTTPWalletJSON_js_1.default(this.originator, 'https://localhost:2121')),
            attemptSubstrate(() => new HTTPWalletJSON_js_1.default(this.originator)),
            attemptSubstrate(() => new ReactNativeWebView_js_1.default(this.originator)),
            attemptSubstrate(() => new WalletWireTransceiver_js_1.default(new HTTPWalletWire_js_1.default(this.originator)))
        ];
        const fastResults = await Promise.allSettled(fastAttempts);
        const fastSuccessful = fastResults
            .filter((r) => r.status === 'fulfilled' && r.value.success && r.value.sub !== undefined)
            .map(r => r.value.sub);
        if (fastSuccessful.length > 0) {
            this.substrate = fastSuccessful[0];
            return;
        }
        // Fall back to slower XDM substrate
        const xdmResult = await attemptSubstrate(() => new XDM_js_1.default(), MAX_XDM_RESPONSE_WAIT);
        if (xdmResult.success && xdmResult.sub !== undefined) {
            this.substrate = xdmResult.sub;
        }
        else {
            throw new Error('No wallet available over any communication substrate. Install a BSV wallet today!');
        }
    }
    async createAction(args) {
        (0, validationHelpers_js_1.validateCreateActionArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.createAction(args, this.originator);
    }
    async signAction(args) {
        (0, validationHelpers_js_1.validateSignActionArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.signAction(args, this.originator);
    }
    async abortAction(args) {
        (0, validationHelpers_js_1.validateAbortActionArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.abortAction(args, this.originator);
    }
    async listActions(args) {
        (0, validationHelpers_js_1.validateListActionsArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.listActions(args, this.originator);
    }
    async internalizeAction(args) {
        (0, validationHelpers_js_1.validateInternalizeActionArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.internalizeAction(args, this.originator);
    }
    async listOutputs(args) {
        (0, validationHelpers_js_1.validateListOutputsArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.listOutputs(args, this.originator);
    }
    async relinquishOutput(args) {
        (0, validationHelpers_js_1.validateRelinquishOutputArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.relinquishOutput(args, this.originator);
    }
    async getPublicKey(args) {
        await this.connectToSubstrate();
        return await this.substrate.getPublicKey(args, this.originator);
    }
    async revealCounterpartyKeyLinkage(args) {
        await this.connectToSubstrate();
        return await this.substrate.revealCounterpartyKeyLinkage(args, this.originator);
    }
    async revealSpecificKeyLinkage(args) {
        await this.connectToSubstrate();
        return await this.substrate.revealSpecificKeyLinkage(args, this.originator);
    }
    async encrypt(args) {
        await this.connectToSubstrate();
        return await this.substrate.encrypt(args, this.originator);
    }
    async decrypt(args) {
        await this.connectToSubstrate();
        return await this.substrate.decrypt(args, this.originator);
    }
    async createHmac(args) {
        await this.connectToSubstrate();
        return await this.substrate.createHmac(args, this.originator);
    }
    async verifyHmac(args) {
        await this.connectToSubstrate();
        return await this.substrate.verifyHmac(args, this.originator);
    }
    async createSignature(args) {
        await this.connectToSubstrate();
        return await this.substrate.createSignature(args, this.originator);
    }
    async verifySignature(args) {
        await this.connectToSubstrate();
        return await this.substrate.verifySignature(args, this.originator);
    }
    async acquireCertificate(args) {
        if (args.acquisitionProtocol === 'direct') {
            (0, validationHelpers_js_1.validateAcquireDirectCertificateArgs)(args);
        }
        else if (args.acquisitionProtocol === 'issuance') {
            (0, validationHelpers_js_1.validateAcquireIssuanceCertificateArgs)(args);
        }
        else {
            throw new WERR_INVALID_PARAMETER_js_1.WERR_INVALID_PARAMETER('acquisitionProtocol', `valid. ${String(args.acquisitionProtocol)} is unrecognized.`);
        }
        await this.connectToSubstrate();
        return await this.substrate.acquireCertificate(args, this.originator);
    }
    async listCertificates(args) {
        (0, validationHelpers_js_1.validateListCertificatesArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.listCertificates(args, this.originator);
    }
    async proveCertificate(args) {
        (0, validationHelpers_js_1.validateProveCertificateArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.proveCertificate(args, this.originator);
    }
    async relinquishCertificate(args) {
        (0, validationHelpers_js_1.validateRelinquishCertificateArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.relinquishCertificate(args, this.originator);
    }
    async discoverByIdentityKey(args) {
        (0, validationHelpers_js_1.validateDiscoverByIdentityKeyArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.discoverByIdentityKey(args, this.originator);
    }
    async discoverByAttributes(args) {
        (0, validationHelpers_js_1.validateDiscoverByAttributesArgs)(args);
        await this.connectToSubstrate();
        return await this.substrate.discoverByAttributes(args, this.originator);
    }
    async isAuthenticated(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.isAuthenticated(args, this.originator);
    }
    async waitForAuthentication(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.waitForAuthentication(args, this.originator);
    }
    async getHeight(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.getHeight(args, this.originator);
    }
    async getHeaderForHeight(args) {
        await this.connectToSubstrate();
        return await this.substrate.getHeaderForHeight(args, this.originator);
    }
    async getNetwork(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.getNetwork(args, this.originator);
    }
    async getVersion(args = {}) {
        await this.connectToSubstrate();
        return await this.substrate.getVersion(args, this.originator);
    }
}
exports.default = WalletClient;
//# sourceMappingURL=WalletClient.js.map