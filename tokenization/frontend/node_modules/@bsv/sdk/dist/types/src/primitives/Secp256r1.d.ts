export type P256Point = {
    x: bigint;
    y: bigint;
} | null;
type ByteSource = string | Uint8Array | ArrayBufferView;
/**
 * Pure BigInt implementation of the NIST P-256 (secp256r1) curve with ECDSA sign/verify.
 *
 * This class is standalone (no dependency on the existing secp256k1 primitives) and exposes
 * key generation, point encoding/decoding, scalar multiplication, and SHA-256 based ECDSA.
 */
export default class Secp256r1 {
    readonly p: bigint;
    readonly n: bigint;
    readonly a: bigint;
    readonly b: bigint;
    readonly g: {
        x: bigint;
        y: bigint;
    };
    private mod;
    private modInv;
    private modPow;
    private isInfinity;
    private assertOnCurve;
    pointFromAffine(x: bigint, y: bigint): P256Point;
    /**
     * Decode a point from compressed or uncompressed hex.
     */
    pointFromHex(hex: string): P256Point;
    /**
     * Encode a point to compressed or uncompressed hex. Infinity is encoded as `00`.
     */
    pointToHex(p: P256Point, compressed?: boolean): string;
    /**
     * Add two affine points (handles infinity).
     */
    private addPoints;
    private doublePoint;
    /**
     * Add two points (handles infinity).
     */
    add(p1: P256Point, p2: P256Point): P256Point;
    /**
     * Scalar multiply an arbitrary point using double-and-add.
     */
    multiply(point: P256Point, scalar: bigint): P256Point;
    /**
     * Scalar multiply the base point.
     */
    multiplyBase(scalar: bigint): P256Point;
    /**
     * Check if a point lies on the curve (including infinity).
     */
    isOnCurve(p: P256Point): boolean;
    /**
     * Generate a new random private key as 32-byte hex.
     */
    generatePrivateKeyHex(): string;
    private randomScalar;
    private normalizePrivateKey;
    private toScalar;
    publicKeyFromPrivate(privateKey: string | bigint): P256Point;
    /**
     * Create an ECDSA signature over a message. Uses SHA-256 unless `prehashed` is true.
     * Returns low-s normalized signature hex parts.
     */
    sign(message: ByteSource, privateKey: string | bigint, opts?: {
        prehashed?: boolean;
        nonce?: bigint;
    }): {
        r: string;
        s: string;
    };
    /**
     * Verify an ECDSA signature against a message and public key.
     */
    verify(message: ByteSource, signature: {
        r: string | bigint;
        s: string | bigint;
    }, publicKey: P256Point | string, opts?: {
        prehashed?: boolean;
    }): boolean;
    private normalizeMessage;
    private bytesToScalar;
    private deterministicNonce;
    private toBytes;
    private to32BytesHex;
}
export {};
//# sourceMappingURL=Secp256r1.d.ts.map