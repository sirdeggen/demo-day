import Signature from './Signature.js';
import BigNumber from './BigNumber.js';
import Script from '../script/Script.js';
import TransactionInput from '../transaction/TransactionInput.js';
import TransactionOutput from '../transaction/TransactionOutput.js';
export interface SignatureHashCache {
    hashPrevouts?: number[];
    hashSequence?: number[];
    hashOutputsAll?: number[];
    hashOutputsSingle?: Map<number, number[]>;
}
interface TransactionSignatureFormatParams {
    sourceTXID: string;
    sourceOutputIndex: number;
    sourceSatoshis: number;
    transactionVersion: number;
    otherInputs: TransactionInput[];
    outputs: TransactionOutput[];
    inputIndex: number;
    subscript: Script;
    inputSequence: number;
    lockTime: number;
    scope: number;
    cache?: SignatureHashCache;
}
export default class TransactionSignature extends Signature {
    static readonly SIGHASH_ALL = 1;
    static readonly SIGHASH_NONE = 2;
    static readonly SIGHASH_SINGLE = 3;
    static readonly SIGHASH_FORKID = 64;
    static readonly SIGHASH_ANYONECANPAY = 128;
    scope: number;
    /**
     * Formats the SIGHASH preimage for the targeted input, optionally using a cache to skip recomputing shared hash prefixes.
     * @param params - Context for the signing input plus transaction metadata.
     * @param params.cache - Optional cache storing previously computed `hashPrevouts`, `hashSequence`, or `hashOutputs*` values; it will be populated if present.
     */
    static format(params: TransactionSignatureFormatParams): number[];
    /**
     * Formats the same SIGHASH preimage bytes as `format`, supporting the optional cache for hash reuse.
     * @param params - Context for the signing operation.
     * @param params.cache - Optional `SignatureHashCache` that may already contain hashed prefixes and is populated during formatting.
     * @returns Bytes for signing.
     */
    static formatBytes(params: TransactionSignatureFormatParams): Uint8Array;
    static fromChecksigFormat(buf: number[]): TransactionSignature;
    constructor(r: BigNumber, s: BigNumber, scope: number);
    /**
     * Compares to bitcoind's IsLowDERSignature
     * See also Ecdsa signature algorithm which enforces this.
     * See also Bip 62, "low S values in signatures"
     */
    hasLowS(): boolean;
    toChecksigFormat(): number[];
}
export {};
//# sourceMappingURL=TransactionSignature.d.ts.map